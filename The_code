import numpy as np
from math import pi
from scipy.special import gamma 
import matplotlib.pyplot as plt

def nsphere(n, N, seed):
    """This function takes two arguments: the dimension of sphere n (int), N (int) the number of sample points in the [-1.1]^n cube, and an RNG seed (int) for reproducability.
    
       It then returns a single float value. Which is the estimated volume of the sphere. 
    """
    rng = np.random.default_rng(seed)
    x = np.random.uniform(-1,1, (N,n))
    n_sphere = (np.sum(x**2, axis = 1) <= 1)
    n_cube = 2**n
    sphere_mean = n_sphere.mean()
    est_volume = n_cube*sphere_mean
    
    return est_volume 


def exactvol(n):
    """ This is the simple analytic function describing the volume of an n-dim sphere. Its closed form requires the Gamma function."""
    
    return pi**(n/2) / gamma(n/2 + 1)
   


def SD(n,N, seed):
    """ This computes the standard deviation in the estimated volume 
    
        using the typical variance formula for a Bernoulli random variable."""
    rng = np.random.default_rng(seed)
    x = np.random.uniform(-1,1, (N,n))
    n_sphere = (np.sum(x**2, axis = 1) <= 1)
    sphere_mean = n_sphere.mean()
    return  2**n * np.sqrt(sphere_mean*(1- sphere_mean)/N)


#Lets make a graph
dims = list(range(1,25)) #testing accuracy up to dim = 25
errs = [SD(l, 100000, 42) for l in dims] #error bars


y_vals_monte = [nsphere(j,100000, seed = 42) for j in dim] #estimated
y_vals_exact = [exactvol(k) for k in dim] #exact



#plotting
plt.figure()
plt.errorbar(dims, y_vals_monte, yerr = errs, fmt='o', capsize=4, label="Monte Carlo")
plt.scatter(dims, y_vals_exact, label="Exact Volume", color="orange")
plt.xlabel("Dimension, n")
plt.ylabel("Volume of unit n-sphere")
plt.legend()
plt.tight_layout()
plt.ylim(bottom = 0)
plt.show()

        
